// realvirtual (R) Framework for Automation Concept Design, Virtual Commissioning and 3D-HMI
// Copyright(c) 2019 realvirtual GmbH - Usage of this source code only allowed based on License conditions see https://realvirtual.io/en/company/license

using UnityEngine;
using NaughtyAttributes;

namespace realvirtual
{
    [HelpURL("https://doc.realvirtual.io/components-and-scripts/motion/chain-element")]
    [SelectionBase]
    [RequireComponent(typeof(Rigidbody))]
    //! ChainElement represents individual links, buckets, or carriers in continuous chain transport systems.
    //! This component transforms objects into chain-driven transport elements that move along spline paths,
    //! maintaining proper spacing and orientation while transporting materials. Supports automatic alignment
    //! with chain curvature, physics-based collision handling for material interaction, and synchronization
    //! with drive speeds. Essential for bucket elevators, overhead power-and-free systems, chain conveyors,
    //! and other continuous transport applications in manufacturing and material handling.
    public class ChainElement : realvirtualBehavior, IChainElement
    {
        [Header(("Settings"))] 
        [Tooltip("Aligns the chain element to follow the chain tangent direction while moving")]
        public bool
            AlignWithChain = true; //!< true if the chainelement needs to align with the chain tangent while moving

        [Tooltip("Enable physics-based movement for chain elements with colliders")]
        public bool
            MoveRigidBody =
                true; //!< needs to be set to true if chainelements has colliders which should make parts move physically

        [Tooltip("Additional rotation vector for alignment (local Z points to tangent)")]
        [ShowIf("AlignWithChain")] [InfoBox("Z of object to tangent, AlignVector or AlignObjectZ = up")]
        public Vector3 AlignVector = new Vector3(1, 0, 0); //!< additinal rotation for the alignment

        [Tooltip("Reference object whose forward direction defines the up vector for alignment")]
        [ShowIf("AlignWithChain")] public GameObject AlignObjectLocalZUp;

        [Tooltip("Shows debug visualization (Green = Tangent, Red = Up direction)")]
        [ShowIf("AlignWithChain")] [InfoBox("Debug Green = Tangent, Red = Up")]
        public bool DebugDirections;
        
        [Tooltip("Initial position of the chain element along the chain in mm")]
        public float InitialPosition =0;
        [Tooltip("Position offset relative to the drive position in mm")]
        public float OffsetToDrivePosition = 0;
        
        public Drive ConnectedDrive { get; set; } //!< Drive where the chain is connected to
        public float StartPosition { get; set; } //!< Start position of this chain element

        [Tooltip("Reference to the chain (leave null for auto-generated elements)")]
        [InfoBox("Keep this null, if elements are created automatically on Start by defined Number in Chain - if not, connect the chain here")]
        public Chain ConnectedChain;
        public Chain Chain { get; set; } //!< Chain where this chainelement belongs to
        public bool UsePath { get; set; }
        [HideInInspector]public bool UseUnitySpline { get; set; }
        public float Position { get; set; } //!< Current position of this chain element
        public float RelativePosition { get; set; } //!< Relative position of this chain element
        
        
        private Vector3 _targetpos;
        private Quaternion targetrotation;
        private Vector3 tangentforward;
        private realvirtualController realvirtualcontroller;
        private bool chainnotnull = false;
        private bool alignobjectnotnull = false;
        private bool SplineIsVertical = false;
        private bool connecteddrivenotnull = false;
        private Rigidbody _rigidbody;
        private bool autogenerated = false;

        public void InitPos(float pos)
        {
            pos = pos + OffsetToDrivePosition;
            StartPosition = pos;
            InitialPosition= pos;
            if(!UseUnitySpline)
            {
                if (Chain.chainOrientation == ChainOrientation.Vertical)
                {
                    SplineIsVertical = true;
                }

                if (AlignWithChain)
                {
                    RelativePosition = pos / Chain.Length;
                    var positon = Chain.GetPosition(RelativePosition);
                    transform.position = positon;

                    Quaternion rotation = new Quaternion();
                    var tangent = Chain.GetTangent(RelativePosition);
                    Vector3 align = AlignVector;
                    if (alignobjectnotnull)
                    {
                        align = AlignObjectLocalZUp.transform.forward;
                    }

                    Vector3 globaldir = transform.TransformDirection(align);
                    rotation = Quaternion.LookRotation(tangent, globaldir);
                    if (SplineIsVertical)
                    {
                        if (tangent.z < 0 || (tangent.z == 0 && tangent.x > 0))
                        {
                            rotation = Quaternion.LookRotation(tangent, -align);
                        }
                    }
                    transform.rotation = rotation;
                    if (DebugDirections)
                    {
                        Debug.DrawRay(transform.position, tangent, Color.green, 20);
                        Debug.DrawRay(transform.position, align, Color.red);
                    }
                }
            }
            else
            {
                if (AlignWithChain)
                {
                    RelativePosition = pos / Chain.Length;
                    var positon = Chain.GetPosition(RelativePosition);
                    transform.position = positon;
                    
                    var tangent = Chain.GetTangent(RelativePosition);
                    var updirection = Chain.GetUpDirection(RelativePosition);
                    Quaternion rotation = new Quaternion();
                    rotation = Quaternion.LookRotation(tangent, updirection);
                    transform.rotation = rotation;
                    if (DebugDirections)
                    {
                        Debug.DrawRay(transform.position, tangent, Color.green, 20);
                        Debug.DrawRay(transform.position, updirection, Color.red);
                    }
                }
            }
            autogenerated = true;
        }

        public void SetPosition()
        {
            float relevantLength=Chain.Length;
            if (Chain.ScaledOnFixedLength)
            {
                relevantLength = Chain.FixedLength;
            }

            if(Mathf.Abs(Position) > relevantLength)
            {
                Position = Position % relevantLength;
            }
            RelativePosition = (Position < 0 
                                 ? (1 - Mathf.Abs(Position) / relevantLength) 
                                 : (Position / relevantLength));
            
            var positon = Chain.GetPosition(RelativePosition);

            if (MoveRigidBody)
                _rigidbody.MovePosition(positon);
            else
                transform.position = positon;

            _targetpos = transform.position;
            
            if (AlignWithChain)
            {
                Vector3 tangent=Vector3.zero;
                Vector3 align = AlignVector;
                Quaternion rotation = new Quaternion();
                if(!UseUnitySpline)
                {
                    tangent = Chain.GetTangent(RelativePosition);
                    align = AlignVector;
                    if (alignobjectnotnull)
                    {
                        align = AlignObjectLocalZUp.transform.forward;
                    }
                    Vector3 globaldir = Vector3.zero;
                    globaldir = transform.TransformDirection(align);
                    rotation = Quaternion.LookRotation(tangent, globaldir);
                    if (SplineIsVertical)
                    {
                        if (tangent.z < 0 || (tangent.z == 0 && tangent.x > 0))
                        {
                            rotation = Quaternion.LookRotation(tangent, -align);
                        }
                    }
                }
                else
                {
                    
                    tangent = Chain.GetTangent(RelativePosition);
                    align = Chain.GetUpDirection(RelativePosition);
                    rotation = Quaternion.LookRotation(tangent, align);
                }
                if (DebugDirections)
                {
                    Debug.DrawRay(transform.position, tangent, Color.green);
                    Debug.DrawRay(transform.position, align, Color.red);
                }

                if (MoveRigidBody)
                    _rigidbody.MoveRotation(rotation);
                else
                    transform.rotation = rotation;
            }
        }

        public void UpdatePosition(float deltaTime)
        {
            if (!connecteddrivenotnull) return;
            
            Position = ConnectedDrive.CurrentPosition + StartPosition + OffsetToDrivePosition;
            
            SetPosition();
        }

        private void Start()
        {
            var drive =this.GetComponent<Drive>();
            if (drive != null && drive.Direction == DIRECTION.Virtual)
            {
                this.ConnectedDrive = drive;
                connecteddrivenotnull = true;
            }
            _rigidbody = GetComponent<Rigidbody>();
            if (_rigidbody == null)
            {
                _rigidbody = gameObject.AddComponent<Rigidbody>();
                Debug.Log("ChainElement: Rigidbody is missing, automatically added to " + gameObject.name);
            }

            _rigidbody.isKinematic = true;
            alignobjectnotnull = AlignObjectLocalZUp != null;
            
            if (ConnectedChain != null)
            {
                Chain = ConnectedChain;
            }
            else
            {
                ConnectedChain = Chain;
            }

            if (Chain != null)
            {
                chainnotnull = true;
                UseUnitySpline = Chain.unitySplineActive;
                // only use chain drive if no own drive is connected
                if(!connecteddrivenotnull)
                    ConnectedDrive = Chain.ConnectedDrive;
                UsePath = Chain.usepath;
                
                if (Chain.spline != null)
                {
                    Vector3 VectorA = Chain.spline.Anchors[1].Anchor.transform.localPosition -
                                      Chain.spline.Anchors[0].Anchor.transform.localPosition;

                    if (Chain.chainOrientation == ChainOrientation.Vertical)
                    {
                        SplineIsVertical = true;
                    }
                }
                if(InitialPosition!=0)
                {
                    Position = InitialPosition;
                    StartPosition = InitialPosition;
                }
                SetPosition();
            }
            else
                chainnotnull = false;

            if (ConnectedDrive == null && autogenerated)
            {
                Debug.LogError(
                    "No Drive connected to ChainElement, please add a drive to the element itself (for controlling single element) or a drive to the chain (for moving the full chain with one drive)");
            }
            else
            {
                connecteddrivenotnull = ConnectedDrive != null;
            }
            if (connecteddrivenotnull)
            {
                ConnectedDrive.OnAfterDriveCalculation.AddListener(UpdatePosition);
            }
        }
        public void UpdatePosition(Drive drive)
        {
            if (chainnotnull)
                UpdatePosition(0);
        }

    }
}